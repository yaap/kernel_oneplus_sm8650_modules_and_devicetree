// SPDX-License-Identifier: GPL-2.0-only
/*
 * Copyright (C) 2023-2023 Oplus. All rights reserved.
 */

#define pr_fmt(fmt) "[IC_DEBUG]([%s][%d]): " fmt, __func__, __LINE__

#include <oplus_chg_ic.h>

#define OPLUS_CHG_IC_DEBUG_LITTLE_STR_LEN (64)
#define OPLUS_CHG_IC_DEBUG_GAUGE_REG_SIZE 512

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
static int oplus_chg_ic_data_forward(struct oplus_chg_ic_dev *ic,
				     struct oplus_chg_ic_func_data **data)
{
	int rc;

	mutex_lock(&ic->func_call_lock);
	mutex_lock(&ic->func_data_lock);
	ic->func_data = *data;
	ic->func_data_ok = true;
	reinit_completion(&ic->func_data_ack);
	mutex_unlock(&ic->func_data_lock);
	wake_up(&ic->read_wq);
	if (list_empty(&ic->debug.virt_list) &&
	    !ic->debug.trace_en && !ic->debug.virt_en) {
		mutex_unlock(&ic->func_call_lock);
		chg_err("virtualization or trace is already disabled\n");
		return -EINVAL;
	}
	rc = wait_for_completion_timeout(&ic->func_data_ack, msecs_to_jiffies(10000));
	if (!rc) {
		mutex_unlock(&ic->func_call_lock);
		chg_err("wait data ack timeout\n");
		return -EINVAL;
	}
	mutex_lock(&ic->func_data_lock);
	*data = ic->func_data;
	ic->func_data = NULL;
	mutex_unlock(&ic->func_data_lock);
	mutex_unlock(&ic->func_call_lock);

	return 0;
}

static bool oplus_chg_ic_func_virt_is_enable(struct oplus_chg_ic_dev *ic_dev,
					     enum oplus_chg_ic_func func_id)
{
	struct oplus_chg_ic_virt_data *data;

	rcu_read_lock();
	list_for_each_entry_rcu(data, &ic_dev->debug.virt_list, list) {
		if (data->func_id != func_id)
			continue;
		rcu_read_unlock();
		return true;
	}
	rcu_read_unlock();

	return false;
}
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */

/* This file is automatically generated */
#include "oplus_chg_ic_auto_debug.c"

static int ic_debug_gauge_get_batt_vol(struct oplus_chg_ic_dev *ic,
				       int index, int *vol_mv)
{
	OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL_T func =
		(ic && ic->get_func) ?
			ic->get_func(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL) :
			NULL;
#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	struct oplus_chg_ic_func_data *func_data;
	size_t func_data_size;
	bool virt_en;
	bool trace_only;
	s64 *item_data;
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	struct oplus_chg_ic_overwrite_data *overwrite_data;
	const void *buf;
	int rc = 0;

	if (!func)
		return -ENOTSUPP;

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	virt_en = ic->debug.virt_en ||
		  oplus_chg_ic_func_virt_is_enable(
			  ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL);
	trace_only = virt_en ? false : ic->debug.trace_en;

	if (virt_en) {
		func_data_size = sizeof(struct oplus_chg_ic_func_data) +
				 oplus_chg_ic_debug_data_size(1);
		func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
		if (!func_data) {
			chg_err("alloc func data error\n");
			return -ENOMEM;
		}
		func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL;
		func_data->trace_only = trace_only;
		func_data->size = oplus_chg_ic_debug_data_size(1);
		func_data->pid = current->pid;
		oplus_chg_ic_debug_data_init(func_data->buf, 1);
		item_data = oplus_chg_ic_get_item_data_addr(func_data->buf, 0);
		*item_data = index;
		*item_data = cpu_to_le64(*item_data);
		rc = oplus_chg_ic_data_forward(ic, &func_data);
		if (rc < 0) {
			devm_kfree(ic->dev, func_data);
			return rc;
		}
		if (func_data->func_id != OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL) {
			chg_err("func id error, id=%d", func_data->func_id);
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		buf = (const void *)func_data->buf;
		if (!oplus_chg_ic_debug_data_check(buf, func_data->size)) {
			chg_err("func data error");
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		*vol_mv = oplus_chg_ic_get_item_data(buf, 0);
		rc = func_data->return_value;
		devm_kfree(ic->dev, func_data);
	} else {
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
		overwrite_data = oplus_chg_ic_get_overwrite_data(
			ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL);
		if (unlikely(overwrite_data != NULL)) {
			buf = (const void *)overwrite_data->buf;
			if (!oplus_chg_ic_debug_data_check(
				    buf, overwrite_data->size)) {
				chg_err("overwrite data error");
				goto skip_overwrite;
			}
			*vol_mv = oplus_chg_ic_get_item_data(buf, index);
			goto overwrite_done;
		}
skip_overwrite:
		rc = func(ic, index, vol_mv);
overwrite_done:

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
		if (trace_only) {
			/* trace */
			func_data_size = sizeof(struct oplus_chg_ic_func_data) +
					 oplus_chg_ic_debug_data_size(2);
			func_data = devm_kzalloc(ic->dev, func_data_size,
						 GFP_KERNEL);
			if (!func_data) {
				chg_err("alloc func data error\n");
				goto out;
			}
			func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL;
			func_data->trace_only = trace_only;
			func_data->size = oplus_chg_ic_debug_data_size(2);
			func_data->pid = current->pid;
			func_data->return_value = rc;
			oplus_chg_ic_debug_data_init(func_data->buf, 2);
			item_data = oplus_chg_ic_get_item_data_addr(
				func_data->buf, 0);
			*item_data = index;
			*item_data = cpu_to_le64(*item_data);
			item_data = oplus_chg_ic_get_item_data_addr(
				func_data->buf, 1);
			*item_data = *vol_mv;
			*item_data = cpu_to_le64(*item_data);
			oplus_chg_ic_data_forward(ic, &func_data);
		}
	}

out:
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	return rc;
}

static int ic_debug_gauge_get_batt_vol_max(struct oplus_chg_ic_dev *ic, int *vol_mv)
{
	OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX_T func =
		(ic && ic->get_func) ? ic->get_func(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX) : NULL;
#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	struct oplus_chg_ic_func_data *func_data;
	bool virt_en;
	bool trace_only;
	size_t func_data_size;
	s64 *item_data;
#endif
	struct oplus_chg_ic_overwrite_data *overwrite_data;
	const void *buf;
	int i, num;
	s64 tmp;
	int rc = 0;

	if(!func)
		return -ENOTSUPP;

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	virt_en = ic->debug.virt_en || oplus_chg_ic_func_virt_is_enable(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX);
	trace_only = virt_en ? false : ic->debug.trace_en;

	if (virt_en) {
		func_data_size = sizeof(struct oplus_chg_ic_func_data) + oplus_chg_ic_debug_data_size(0);
		func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
		if (!func_data) {
			chg_err("alloc func data error\n");
			return -ENOMEM;
		}
		func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX;
		func_data->trace_only = trace_only;
		func_data->size = oplus_chg_ic_debug_data_size(0);
		func_data->pid = current->pid;
		rc = oplus_chg_ic_data_forward(ic, &func_data);
		if (rc < 0) {
			devm_kfree(ic->dev, func_data);
			return rc;
		}
		if (func_data->func_id != OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX) {
			chg_err("func id error, id=%d\n", func_data->func_id);
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		buf = (const void *)func_data->buf;
		if (!oplus_chg_ic_debug_data_check(buf, func_data->size)) {
			chg_err("func data error\n");
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		*vol_mv = oplus_chg_ic_get_item_data(buf, 0);
		rc = func_data->return_value;
		devm_kfree(ic->dev, func_data);
	} else {
#endif
		overwrite_data = oplus_chg_ic_get_overwrite_data(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX);
		if (unlikely(overwrite_data != NULL)) {
			buf = (const void *)overwrite_data->buf;
			if (!oplus_chg_ic_debug_data_check(buf, overwrite_data->size)) {
				chg_err("overwrite data error\n");
				goto skip_overwrite;
			}
			*vol_mv = oplus_chg_ic_get_item_data(buf, 0);
			goto overwrite_done;
		}

		overwrite_data = oplus_chg_ic_get_overwrite_data(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL);
		if (unlikely(overwrite_data != NULL)) {
			buf = (const void *)overwrite_data->buf;
			if (!oplus_chg_ic_debug_data_check(buf, overwrite_data->size)) {
				chg_err("overwrite data error\n");
				goto skip_overwrite;
			}
			num = oplus_chg_ic_get_item_num(buf, overwrite_data->size);
			if (num <= 0)
				goto skip_overwrite;
			tmp = 0;
			*vol_mv = 0;
			for (i = 0; i < num; i++) {
				tmp = oplus_chg_ic_get_item_data(buf, i);
				if (i == 0 || tmp > *vol_mv)
					*vol_mv = tmp;
			}
			goto overwrite_done;
		}
skip_overwrite:
		rc = func(ic, vol_mv);
overwrite_done:

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
		if (trace_only) {
			/* trace */
			func_data_size = sizeof(struct oplus_chg_ic_func_data) + oplus_chg_ic_debug_data_size(1);
			func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
			if (!func_data) {
				chg_err("alloc func data error\n");
				goto out;
			}
			func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX;
			func_data->trace_only = trace_only;
			func_data->size = oplus_chg_ic_debug_data_size(1);
			func_data->pid = current->pid;
			func_data->return_value = rc;
			oplus_chg_ic_debug_data_init(func_data->buf, 1);
			item_data = oplus_chg_ic_get_item_data_addr(func_data->buf, 0);
			*item_data = *vol_mv;
			*item_data = cpu_to_le64(*item_data);
			oplus_chg_ic_data_forward(ic, &func_data);
		}
	}

out:
#endif
	return rc;
}

static int ic_debug_gauge_get_batt_vol_min(struct oplus_chg_ic_dev *ic, int *vol_mv)
{
	OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN_T func =
		(ic && ic->get_func) ? ic->get_func(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN) : NULL;
#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	struct oplus_chg_ic_func_data *func_data;
	bool virt_en;
	bool trace_only;
	size_t func_data_size;
	s64 *item_data;
#endif
	struct oplus_chg_ic_overwrite_data *overwrite_data;
	const void *buf;
	int i, num;
	s64 tmp;
	int rc = 0;

	if(!func)
		return -ENOTSUPP;

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	virt_en = ic->debug.virt_en || oplus_chg_ic_func_virt_is_enable(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN);
	trace_only = virt_en ? false : ic->debug.trace_en;

	if (virt_en) {
		func_data_size = sizeof(struct oplus_chg_ic_func_data) + oplus_chg_ic_debug_data_size(0);
		func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
		if (!func_data) {
			chg_err("alloc func data error\n");
			return -ENOMEM;
		}
		func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN;
		func_data->trace_only = trace_only;
		func_data->size = oplus_chg_ic_debug_data_size(0);
		func_data->pid = current->pid;
		rc = oplus_chg_ic_data_forward(ic, &func_data);
		if (rc < 0) {
			devm_kfree(ic->dev, func_data);
			return rc;
		}
		if (func_data->func_id != OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN) {
			chg_err("func id error, id=%d\n", func_data->func_id);
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		buf = (const void *)func_data->buf;
		if (!oplus_chg_ic_debug_data_check(buf, func_data->size)) {
			chg_err("func data error\n");
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		*vol_mv = oplus_chg_ic_get_item_data(buf, 0);
		rc = func_data->return_value;
		devm_kfree(ic->dev, func_data);
	} else {
#endif
		overwrite_data = oplus_chg_ic_get_overwrite_data(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN);
		if (unlikely(overwrite_data != NULL)) {
			buf = (const void *)overwrite_data->buf;
			if (!oplus_chg_ic_debug_data_check(buf, overwrite_data->size)) {
				chg_err("overwrite data error\n");
				goto skip_overwrite;
			}
			*vol_mv = oplus_chg_ic_get_item_data(buf, 0);
			goto overwrite_done;
		}

		overwrite_data = oplus_chg_ic_get_overwrite_data(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL);
		if (unlikely(overwrite_data != NULL)) {
			buf = (const void *)overwrite_data->buf;
			if (!oplus_chg_ic_debug_data_check(buf, overwrite_data->size)) {
				chg_err("overwrite data error\n");
				goto skip_overwrite;
			}
			num = oplus_chg_ic_get_item_num(buf, overwrite_data->size);
			if (num <= 0)
				goto skip_overwrite;
			tmp = 0;
			*vol_mv = 0;
			for (i = 0; i < num; i++) {
				tmp = oplus_chg_ic_get_item_data(buf, i);
				if (i == 0 || tmp < *vol_mv)
					*vol_mv = tmp;
			}
			goto overwrite_done;
		}
skip_overwrite:
		rc = func(ic, vol_mv);
overwrite_done:

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
		if (trace_only) {
			/* trace */
			func_data_size = sizeof(struct oplus_chg_ic_func_data) + oplus_chg_ic_debug_data_size(1);
			func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
			if (!func_data) {
				chg_err("alloc func data error\n");
				goto out;
			}
			func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN;
			func_data->trace_only = trace_only;
			func_data->size = oplus_chg_ic_debug_data_size(1);
			func_data->pid = current->pid;
			func_data->return_value = rc;
			oplus_chg_ic_debug_data_init(func_data->buf, 1);
			item_data = oplus_chg_ic_get_item_data_addr(func_data->buf, 0);
			*item_data = *vol_mv;
			*item_data = cpu_to_le64(*item_data);
			oplus_chg_ic_data_forward(ic, &func_data);
		}
	}

out:
#endif
	return rc;
}

static int ic_debug_gauge_get_batt_sn(struct oplus_chg_ic_dev *ic, char *sn_buf, int len)
{
	OPLUS_IC_FUNC_GAUGE_GET_BATT_SN_T func =
		(ic && ic->get_func) ? ic->get_func(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_SN) : NULL;
#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	struct oplus_chg_ic_func_data *func_data;
	bool virt_en;
	bool trace_only;
	size_t func_data_size;
	s64 *item_data;
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	struct oplus_chg_ic_overwrite_data *overwrite_data;
	const void *buf;
	int rc = 0;
	int index;

	if (!func)
		return -ENOTSUPP;

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	virt_en = ic->debug.virt_en || oplus_chg_ic_func_virt_is_enable(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_SN);
	trace_only = virt_en ? false : ic->debug.trace_en;

	if (virt_en) {
		func_data_size = sizeof(struct oplus_chg_ic_func_data) + oplus_chg_ic_debug_data_size(1);
		func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
		if (!func_data) {
			chg_err("alloc func data error\n");
			return -ENOMEM;
		}
		func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_BATT_SN;
		func_data->trace_only = trace_only;
		func_data->size = oplus_chg_ic_debug_data_size(1);
		func_data->pid = current->pid;
		oplus_chg_ic_debug_data_init(func_data->buf, 1);
		item_data = oplus_chg_ic_get_item_data_addr(func_data->buf, 0);
		*item_data = len;
		*item_data = cpu_to_le64(*item_data);
		rc = oplus_chg_ic_data_forward(ic, &func_data);
		if (rc < 0) {
			devm_kfree(ic->dev, func_data);
			return rc;
		}
		if (func_data->func_id != OPLUS_IC_FUNC_GAUGE_GET_BATT_SN) {
			chg_err("func id error, id=%d\n", func_data->func_id);
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		buf = (const void *)func_data->buf;
		if (!oplus_chg_ic_debug_data_check(buf, func_data->size)) {
			chg_err("func data error\n");
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		index = oplus_chg_ic_get_item_data_size(buf, 0) >= len ? len : oplus_chg_ic_get_item_data_size(buf, 0);
		memcpy(sn_buf, oplus_chg_ic_get_item_data_addr(func_data->buf, 0), index);
		rc = func_data->return_value;
		devm_kfree(ic->dev, func_data);
	} else {
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
		overwrite_data = oplus_chg_ic_get_overwrite_data(ic, OPLUS_IC_FUNC_GAUGE_GET_BATT_SN);
		if (unlikely(overwrite_data != NULL)) {
			buf = (const void *)overwrite_data->buf;
			if (!oplus_chg_ic_debug_data_check(buf, overwrite_data->size)) {
				chg_err("overwrite data error\n");
				goto skip_overwrite;
			}
			index = oplus_chg_ic_get_item_data_size(buf, 0);
			rc = index >= len ? len : index;
			memcpy(sn_buf, oplus_chg_ic_get_item_data_addr(overwrite_data->buf, 0), rc);
			goto overwrite_done;
		}
skip_overwrite:
		rc = func(ic, sn_buf, len);
overwrite_done:

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
		if (trace_only) {
			/* trace */
			func_data_size = sizeof(struct oplus_chg_ic_func_data) + len;
			func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
			if (!func_data) {
				chg_err("alloc func data error\n");
				goto out;
			}
			func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_BATT_SN;
			func_data->trace_only = trace_only;
			func_data->size = len;
			func_data->pid = current->pid;
			func_data->return_value = rc;
			oplus_chg_ic_debug_str_data_init(func_data->buf, len);
			if (rc > 0)
				memcpy(oplus_chg_ic_get_item_data_addr(func_data->buf, 0), sn_buf, rc);
			oplus_chg_ic_data_forward(ic, &func_data);
		}
	}

out:
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	return rc;
}

static int ic_debug_gauge_get_batt_manudate(struct oplus_chg_ic_dev *ic, char *manudate_buf, int len)
{
	OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE_T func =
		(ic && ic->get_func) ? ic->get_func(ic, OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE) : NULL;
#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	struct oplus_chg_ic_func_data *func_data;
	bool virt_en;
	bool trace_only;
	size_t func_data_size;
	s64 *item_data;
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	struct oplus_chg_ic_overwrite_data *overwrite_data;
	const void *buf;
	int rc = 0;
	int index;

	if (!func)
		return -ENOTSUPP;

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	virt_en = ic->debug.virt_en || oplus_chg_ic_func_virt_is_enable(ic, OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE);
	trace_only = virt_en ? false : ic->debug.trace_en;

	if (virt_en) {
		func_data_size = sizeof(struct oplus_chg_ic_func_data) + oplus_chg_ic_debug_data_size(1);
		func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
		if (!func_data) {
			chg_err("alloc func data error\n");
			return -ENOMEM;
		}
		func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE;
		func_data->trace_only = trace_only;
		func_data->size = oplus_chg_ic_debug_data_size(1);
		func_data->pid = current->pid;
		oplus_chg_ic_debug_data_init(func_data->buf, 1);
		item_data = oplus_chg_ic_get_item_data_addr(func_data->buf, 0);
		*item_data = len;
		*item_data = cpu_to_le64(*item_data);
		rc = oplus_chg_ic_data_forward(ic, &func_data);
		if (rc < 0) {
			devm_kfree(ic->dev, func_data);
			return rc;
		}
		if (func_data->func_id != OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE) {
			chg_err("func id error, id=%d\n", func_data->func_id);
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		buf = (const void *)func_data->buf;
		if (!oplus_chg_ic_debug_data_check(buf, func_data->size)) {
			chg_err("func data error\n");
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		index = oplus_chg_ic_get_item_data_size(buf, 0) >= len ? len : oplus_chg_ic_get_item_data_size(buf, 0);
		memcpy(manudate_buf, oplus_chg_ic_get_item_data_addr(func_data->buf, 0), index);
		rc = func_data->return_value;
		devm_kfree(ic->dev, func_data);
	} else {
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
		overwrite_data = oplus_chg_ic_get_overwrite_data(ic, OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE);
		if (unlikely(overwrite_data != NULL)) {
			buf = (const void *)overwrite_data->buf;
			if (!oplus_chg_ic_debug_data_check(buf, overwrite_data->size)) {
				chg_err("overwrite data error\n");
				goto skip_overwrite;
			}
			index = oplus_chg_ic_get_item_data_size(buf, 0);
			rc = index >= len ? len : index;
			memcpy(manudate_buf, oplus_chg_ic_get_item_data_addr(overwrite_data->buf, 0), rc);
			goto overwrite_done;
		}
skip_overwrite:
		rc = func(ic, manudate_buf, len);
overwrite_done:

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
		if (trace_only) {
			/* trace */
			func_data_size = sizeof(struct oplus_chg_ic_func_data) + len;
			func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
			if (!func_data) {
				chg_err("alloc func data error\n");
				goto out;
			}
			func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE;
			func_data->trace_only = trace_only;
			func_data->size = len;
			func_data->pid = current->pid;
			func_data->return_value = rc;
			oplus_chg_ic_debug_str_data_init(func_data->buf, len);
			if (rc > 0)
				memcpy(oplus_chg_ic_get_item_data_addr(func_data->buf, 0), manudate_buf, rc);
			oplus_chg_ic_data_forward(ic, &func_data);
		}
	}

out:
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	return rc;
}

static int ic_debug_gauge_get_batt_firstusagedate(struct oplus_chg_ic_dev *ic, char *fudate_buf, int len)
{
	OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE_T func =
		(ic && ic->get_func) ? ic->get_func(ic, OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE) : NULL;
#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	struct oplus_chg_ic_func_data *func_data;
	bool virt_en;
	bool trace_only;
	size_t func_data_size;
	s64 *item_data;
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	struct oplus_chg_ic_overwrite_data *overwrite_data;
	const void *buf;
	int rc = 0;
	int index;

	if (!func)
		return -ENOTSUPP;

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	virt_en = ic->debug.virt_en || oplus_chg_ic_func_virt_is_enable(ic, OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE);
	trace_only = virt_en ? false : ic->debug.trace_en;

	if (virt_en) {
		func_data_size = sizeof(struct oplus_chg_ic_func_data) + oplus_chg_ic_debug_data_size(1);
		func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
		if (!func_data) {
			chg_err("alloc func data error\n");
			return -ENOMEM;
		}
		func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE;
		func_data->trace_only = trace_only;
		func_data->size = oplus_chg_ic_debug_data_size(1);
		func_data->pid = current->pid;
		oplus_chg_ic_debug_data_init(func_data->buf, 1);
		item_data = oplus_chg_ic_get_item_data_addr(func_data->buf, 0);
		*item_data = len;
		*item_data = cpu_to_le64(*item_data);
		rc = oplus_chg_ic_data_forward(ic, &func_data);
		if (rc < 0) {
			devm_kfree(ic->dev, func_data);
			return rc;
		}
		if (func_data->func_id != OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE) {
			chg_err("func id error, id=%d\n", func_data->func_id);
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		buf = (const void *)func_data->buf;
		if (!oplus_chg_ic_debug_data_check(buf, func_data->size)) {
			chg_err("func data error\n");
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		index = oplus_chg_ic_get_item_data_size(buf, 0) >= len ? len : oplus_chg_ic_get_item_data_size(buf, 0);
		memcpy(fudate_buf, oplus_chg_ic_get_item_data_addr(func_data->buf, 0), index);
		rc = func_data->return_value;
		devm_kfree(ic->dev, func_data);
	} else {
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
		overwrite_data = oplus_chg_ic_get_overwrite_data(ic, OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE);
		if (unlikely(overwrite_data != NULL)) {
			buf = (const void *)overwrite_data->buf;
			if (!oplus_chg_ic_debug_data_check(buf, overwrite_data->size)) {
				chg_err("overwrite data error\n");
				goto skip_overwrite;
			}
			index = oplus_chg_ic_get_item_data_size(buf, 0);
			rc = index >= len ? len : index;
			memcpy(fudate_buf, oplus_chg_ic_get_item_data_addr(overwrite_data->buf, 0), rc);
			goto overwrite_done;
		}
skip_overwrite:
		rc = func(ic, fudate_buf, len);
overwrite_done:

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
		if (trace_only) {
			/* trace */
			func_data_size = sizeof(struct oplus_chg_ic_func_data) + len;
			func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
			if (!func_data) {
				chg_err("alloc func data error\n");
				goto out;
			}
			func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE;
			func_data->trace_only = trace_only;
			func_data->size = len;
			func_data->pid = current->pid;
			func_data->return_value = rc;
			oplus_chg_ic_debug_str_data_init(func_data->buf, len);
			if (rc > 0)
				memcpy(oplus_chg_ic_get_item_data_addr(func_data->buf, 0), fudate_buf, rc);
			oplus_chg_ic_data_forward(ic, &func_data);
		}
	}

out:
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	return rc;
}

static int ic_debug_gauge_get_reg_info(struct oplus_chg_ic_dev *ic, u8 *reg_buf, int len)
{
	OPLUS_IC_FUNC_GAUGE_GET_REG_INFO_T func =
		(ic && ic->get_func) ? ic->get_func(ic, OPLUS_IC_FUNC_GAUGE_GET_REG_INFO) : NULL;
#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	struct oplus_chg_ic_func_data *func_data;
	bool virt_en;
	bool trace_only;
	size_t func_data_size;
	s64 *item_data;
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	struct oplus_chg_ic_overwrite_data *overwrite_data;
	const void *buf;
	int rc = 0;
	int index;

	if (!func)
		return -ENOTSUPP;

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	virt_en = ic->debug.virt_en || oplus_chg_ic_func_virt_is_enable(ic, OPLUS_IC_FUNC_GAUGE_GET_REG_INFO);
	trace_only = virt_en ? false : ic->debug.trace_en;

	if (virt_en) {
		func_data_size = sizeof(struct oplus_chg_ic_func_data) + oplus_chg_ic_debug_data_size(1);
		func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
		if (!func_data) {
			chg_err("alloc func data error\n");
			return -ENOMEM;
		}
		func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_REG_INFO;
		func_data->trace_only = trace_only;
		func_data->size = oplus_chg_ic_debug_data_size(1);
		func_data->pid = current->pid;
		oplus_chg_ic_debug_data_init(func_data->buf, 1);
		item_data = oplus_chg_ic_get_item_data_addr(func_data->buf, 0);
		*item_data = len;
		*item_data = cpu_to_le64(*item_data);
		rc = oplus_chg_ic_data_forward(ic, &func_data);
		if (rc < 0) {
			devm_kfree(ic->dev, func_data);
			return rc;
		}
		if (func_data->func_id != OPLUS_IC_FUNC_GAUGE_GET_REG_INFO) {
			chg_err("func id error, id=%d\n", func_data->func_id);
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		buf = (const void *)func_data->buf;
		if (!oplus_chg_ic_debug_data_check(buf, func_data->size)) {
			chg_err("func data error\n");
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		index = oplus_chg_ic_get_item_data_size(buf, 0) >= len ? len : oplus_chg_ic_get_item_data_size(buf, 0);
		memcpy(reg_buf, oplus_chg_ic_get_item_data_addr(func_data->buf, 0), index);
		rc = func_data->return_value;
		devm_kfree(ic->dev, func_data);
	} else {
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
		overwrite_data = oplus_chg_ic_get_overwrite_data(ic, OPLUS_IC_FUNC_GAUGE_GET_REG_INFO);
		if (unlikely(overwrite_data != NULL)) {
			buf = (const void *)overwrite_data->buf;
			if (!oplus_chg_ic_debug_data_check(buf, overwrite_data->size)) {
				chg_err("overwrite data error\n");
				goto skip_overwrite;
			}
			index = oplus_chg_ic_get_item_data_size(buf, 0);
			rc = index >= len ? len : index;
			memcpy(reg_buf, oplus_chg_ic_get_item_data_addr(overwrite_data->buf, 0), rc);
			goto overwrite_done;
		}
skip_overwrite:
		rc = func(ic, reg_buf, len);
overwrite_done:

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
		if (trace_only) {
			/* trace */
			func_data_size = sizeof(struct oplus_chg_ic_func_data) + len;
			func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
			if (!func_data) {
				chg_err("alloc func data error\n");
				goto out;
			}
			func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_REG_INFO;
			func_data->trace_only = trace_only;
			func_data->size = len;
			func_data->pid = current->pid;
			func_data->return_value = rc;
			oplus_chg_ic_debug_str_data_init(func_data->buf, len);
			if (rc > 0)
				memcpy(oplus_chg_ic_get_item_data_addr(func_data->buf, 0), reg_buf, rc);
			oplus_chg_ic_data_forward(ic, &func_data);
		}
	}

out:
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	return rc;
}

static int ic_debug_gauge_get_lifetime_info(struct oplus_chg_ic_dev *ic, u8 *lifetime_buf, int len)
{
	OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO_T func =
		(ic && ic->get_func) ? ic->get_func(ic, OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO) : NULL;
#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	struct oplus_chg_ic_func_data *func_data;
	bool virt_en;
	bool trace_only;
	size_t func_data_size;
	s64 *item_data;
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	struct oplus_chg_ic_overwrite_data *overwrite_data;
	const void *buf;
	int rc = 0;
	int index;

	if (!func)
		return -ENOTSUPP;

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
	virt_en = ic->debug.virt_en || oplus_chg_ic_func_virt_is_enable(ic, OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO);
	trace_only = virt_en ? false : ic->debug.trace_en;

	if (virt_en) {
		func_data_size = sizeof(struct oplus_chg_ic_func_data) + oplus_chg_ic_debug_data_size(1);
		func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
		if (!func_data) {
			chg_err("alloc func data error\n");
			return -ENOMEM;
		}
		func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO;
		func_data->trace_only = trace_only;
		func_data->size = oplus_chg_ic_debug_data_size(1);
		func_data->pid = current->pid;
		oplus_chg_ic_debug_data_init(func_data->buf, 1);
		item_data = oplus_chg_ic_get_item_data_addr(func_data->buf, 0);
		*item_data = len;
		*item_data = cpu_to_le64(*item_data);
		rc = oplus_chg_ic_data_forward(ic, &func_data);
		if (rc < 0) {
			devm_kfree(ic->dev, func_data);
			return rc;
		}
		if (func_data->func_id != OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO) {
			chg_err("func id error, id=%d\n", func_data->func_id);
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		buf = (const void *)func_data->buf;
		if (!oplus_chg_ic_debug_data_check(buf, func_data->size)) {
			chg_err("func data error\n");
			devm_kfree(ic->dev, func_data);
			return -EINVAL;
		}
		index = oplus_chg_ic_get_item_data_size(buf, 0) >= len ? len : oplus_chg_ic_get_item_data_size(buf, 0);
		memcpy(lifetime_buf, oplus_chg_ic_get_item_data_addr(func_data->buf, 0), index);
		rc = func_data->return_value;
		devm_kfree(ic->dev, func_data);
	} else {
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
		overwrite_data = oplus_chg_ic_get_overwrite_data(ic, OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO);
		if (unlikely(overwrite_data != NULL)) {
			buf = (const void *)overwrite_data->buf;
			if (!oplus_chg_ic_debug_data_check(buf, overwrite_data->size)) {
				chg_err("overwrite data error\n");
				goto skip_overwrite;
			}
			index = oplus_chg_ic_get_item_data_size(buf, 0);
			rc = index >= len ? len : index;
			memcpy(lifetime_buf, oplus_chg_ic_get_item_data_addr(overwrite_data->buf, 0), rc);
			goto overwrite_done;
		}
skip_overwrite:
		rc = func(ic, lifetime_buf, len);
overwrite_done:

#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL)
		if (trace_only) {
			/* trace */
			func_data_size = sizeof(struct oplus_chg_ic_func_data) + len;
			func_data = devm_kzalloc(ic->dev, func_data_size, GFP_KERNEL);
			if (!func_data) {
				chg_err("alloc func data error\n");
				goto out;
			}
			func_data->func_id = OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO;
			func_data->trace_only = trace_only;
			func_data->size = len;
			func_data->pid = current->pid;
			func_data->return_value = rc;
			oplus_chg_ic_debug_str_data_init(func_data->buf, len);
			if (rc > 0)
				memcpy(oplus_chg_ic_get_item_data_addr(func_data->buf, 0), lifetime_buf, rc);
			oplus_chg_ic_data_forward(ic, &func_data);
		}
	}

out:
#endif /* CONFIG_OPLUS_FEATURE_CHG_IC_VIRTUAL */
	return rc;
}

void *oplus_chg_ic_debug_get_func(struct oplus_chg_ic_dev *ic_dev,
				  enum oplus_chg_ic_func func_id)
{
	void *func = NULL;

	switch (func_id) {
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL:
		func = OPLUS_CHG_IC_FUNC_CHECK(OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL,
					       ic_debug_gauge_get_batt_vol);
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX:
		func = OPLUS_CHG_IC_FUNC_CHECK(OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX,
					       ic_debug_gauge_get_batt_vol_max);
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN:
		func = OPLUS_CHG_IC_FUNC_CHECK(OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN,
					       ic_debug_gauge_get_batt_vol_min);
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_SN:
		func = OPLUS_CHG_IC_FUNC_CHECK(OPLUS_IC_FUNC_GAUGE_GET_BATT_SN,
					       ic_debug_gauge_get_batt_sn);
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE:
		func = OPLUS_CHG_IC_FUNC_CHECK(OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE,
					       ic_debug_gauge_get_batt_manudate);
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE:
		func = OPLUS_CHG_IC_FUNC_CHECK(OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE,
					       ic_debug_gauge_get_batt_firstusagedate);
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_REG_INFO:
		func = OPLUS_CHG_IC_FUNC_CHECK(OPLUS_IC_FUNC_GAUGE_GET_REG_INFO,
					       ic_debug_gauge_get_reg_info);
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO:
		func = OPLUS_CHG_IC_FUNC_CHECK(OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO,
					       ic_debug_gauge_get_lifetime_info);
		break;
	default:
		func = ic_auto_debug_get_func(func_id);
		break;
	}

	if ((func == NULL) && (ic_dev->get_func != NULL))
		return ic_dev->get_func(ic_dev, func_id);

	return func;
}

bool oplus_chg_ic_overwrite_support(enum oplus_chg_ic_func func_id)
{
	switch (func_id) {
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL:
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX:
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN:
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_SN:
	case OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE:
	case OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE:
	case OPLUS_IC_FUNC_GAUGE_GET_REG_INFO:
	case OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO:
		return true;
	default:
		return ic_auto_debug_overwrite_support(func_id);
	}

	return false;
}

ssize_t oplus_chg_ic_debug_get_func_data(struct oplus_chg_ic_dev *ic_dev,
	enum oplus_chg_ic_func func_id, void *buf)
{
	s64 *item_data;
	int batt_num, i, len;
	char *tmp_buf;
	int rc = 0;

	switch (func_id) {
	case OPLUS_IC_FUNC_SMT_TEST:
		tmp_buf = (char *)get_zeroed_page(GFP_KERNEL);
		if (!tmp_buf) {
			rc = -ENOMEM;
			break;
		}
		rc = oplus_chg_ic_func(ic_dev, OPLUS_IC_FUNC_SMT_TEST, tmp_buf, PAGE_SIZE);
		if (rc < 0) {
			free_page((unsigned long)tmp_buf);
			break;
		}
		len = oplus_chg_ic_debug_str_data_init(buf, rc);
		memcpy(oplus_chg_ic_get_item_data_addr(buf, 0), tmp_buf, rc);
		free_page((unsigned long)tmp_buf);
		rc = len;
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL:
		rc = oplus_chg_ic_func(ic_dev, OPLUS_IC_FUNC_GAUGE_GET_BATT_NUM,
				       &batt_num);
		if (rc < 0)
			break;
		oplus_chg_ic_debug_data_init(buf, batt_num);
		for (i = 0; i < batt_num; i++) {
			item_data = oplus_chg_ic_get_item_data_addr(buf, i);
			rc = oplus_chg_ic_func(ic_dev, OPLUS_IC_FUNC_GAUGE_GET_BATT_VOL, i, (int *)item_data);
			if (rc < 0)
				break;
			*item_data = cpu_to_le64(*item_data);
		}
		rc = oplus_chg_ic_debug_data_size(batt_num);
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX:
		oplus_chg_ic_debug_data_init(buf, 1);
		item_data = oplus_chg_ic_get_item_data_addr(buf, 0);
		rc = oplus_chg_ic_func(ic_dev, OPLUS_IC_FUNC_GAUGE_GET_BATT_MAX, (int *)item_data);
		if (rc < 0)
			break;
		*item_data = cpu_to_le64(*item_data);
		rc = oplus_chg_ic_debug_data_size(1);
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN:
		oplus_chg_ic_debug_data_init(buf, 1);
		item_data = oplus_chg_ic_get_item_data_addr(buf, 0);
		rc = oplus_chg_ic_func(ic_dev, OPLUS_IC_FUNC_GAUGE_GET_BATT_MIN, (int *)item_data);
		if (rc < 0)
			break;
		*item_data = cpu_to_le64(*item_data);
		rc = oplus_chg_ic_debug_data_size(1);
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_BATT_SN:
		tmp_buf = (char *)devm_kzalloc(ic_dev->dev, OPLUS_CHG_IC_DEBUG_LITTLE_STR_LEN, GFP_KERNEL);
		if (!tmp_buf) {
			rc = -ENOMEM;
			break;
		}
		rc = oplus_chg_ic_func(ic_dev, OPLUS_IC_FUNC_GAUGE_GET_BATT_SN, tmp_buf,
				OPLUS_CHG_IC_DEBUG_LITTLE_STR_LEN);
		if (rc < 0) {
			devm_kfree(ic_dev->dev, tmp_buf);
			break;
		}
		len = oplus_chg_ic_debug_str_data_init(buf, rc);
		memcpy(oplus_chg_ic_get_item_data_addr(buf, 0), tmp_buf, rc);
		devm_kfree(ic_dev->dev, tmp_buf);
		rc = len;
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE:
		tmp_buf = (char *)devm_kzalloc(ic_dev->dev, OPLUS_CHG_IC_DEBUG_LITTLE_STR_LEN, GFP_KERNEL);
		if (!tmp_buf) {
			rc = -ENOMEM;
			break;
		}
		rc = oplus_chg_ic_func(ic_dev, OPLUS_IC_FUNC_GAUGE_GET_MANU_DATE, tmp_buf,
				OPLUS_CHG_IC_DEBUG_LITTLE_STR_LEN);
		if (rc < 0) {
			devm_kfree(ic_dev->dev, tmp_buf);
			break;
		}
		len = oplus_chg_ic_debug_str_data_init(buf, rc);
		memcpy(oplus_chg_ic_get_item_data_addr(buf, 0), tmp_buf, rc);
		devm_kfree(ic_dev->dev, tmp_buf);
		rc = len;
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE:
		tmp_buf = (char *)devm_kzalloc(ic_dev->dev, OPLUS_CHG_IC_DEBUG_LITTLE_STR_LEN, GFP_KERNEL);
		if (!tmp_buf) {
			rc = -ENOMEM;
			break;
		}
		rc = oplus_chg_ic_func(ic_dev, OPLUS_IC_FUNC_GAUGE_GET_FIRST_USAGE_DATE, tmp_buf,
				OPLUS_CHG_IC_DEBUG_LITTLE_STR_LEN);
		if (rc < 0) {
			devm_kfree(ic_dev->dev, tmp_buf);
			break;
		}
		len = oplus_chg_ic_debug_str_data_init(buf, rc);
		memcpy(oplus_chg_ic_get_item_data_addr(buf, 0), tmp_buf, rc);
		devm_kfree(ic_dev->dev, tmp_buf);
		rc = len;
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_REG_INFO:
		tmp_buf = (char *)devm_kzalloc(ic_dev->dev, OPLUS_CHG_IC_DEBUG_GAUGE_REG_SIZE, GFP_KERNEL);
		if (!tmp_buf) {
			rc = -ENOMEM;
			break;
		}
		rc = oplus_chg_ic_func(ic_dev, OPLUS_IC_FUNC_GAUGE_GET_REG_INFO, tmp_buf,
				OPLUS_CHG_IC_DEBUG_GAUGE_REG_SIZE);
		if (rc < 0) {
			devm_kfree(ic_dev->dev, tmp_buf);
			break;
		}
		len = oplus_chg_ic_debug_str_data_init(buf, rc);
		memcpy(oplus_chg_ic_get_item_data_addr(buf, 0), tmp_buf, rc);
		devm_kfree(ic_dev->dev, tmp_buf);
		rc = len;
		break;
	case OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO:
		tmp_buf = (char *)devm_kzalloc(ic_dev->dev, OPLUS_CHG_IC_DEBUG_GAUGE_REG_SIZE, GFP_KERNEL);
		if (!tmp_buf) {
			rc = -ENOMEM;
			break;
		}
		rc = oplus_chg_ic_func(ic_dev, OPLUS_IC_FUNC_GAUGE_GET_SILI_LIFETIME_INFO, tmp_buf,
				OPLUS_CHG_IC_DEBUG_GAUGE_REG_SIZE);
		if (rc < 0) {
			devm_kfree(ic_dev->dev, tmp_buf);
			break;
		}
		len = oplus_chg_ic_debug_str_data_init(buf, rc);
		memcpy(oplus_chg_ic_get_item_data_addr(buf, 0), tmp_buf, rc);
		devm_kfree(ic_dev->dev, tmp_buf);
		rc = len;
		break;
	default:
		rc = oplus_chg_ic_auto_debug_get_func_data(ic_dev, func_id, buf);
	}

	if (rc == -ENOTSUPP && ic_dev->debug.get_func_data != NULL)
		return ic_dev->debug.get_func_data(ic_dev, func_id, buf);

	return rc;
}

int oplus_chg_ic_debug_set_func_data(struct oplus_chg_ic_dev *ic_dev,
	enum oplus_chg_ic_func func_id, const void *buf, size_t buf_size)
{
	int rc = 0;

	if (!ic_dev->online && (func_id != OPLUS_IC_FUNC_INIT) &&
	    (func_id != OPLUS_IC_FUNC_EXIT))
		return -EINVAL;

	switch (func_id) {
	default:
		rc = oplus_chg_ic_auto_debug_set_func_data(ic_dev, func_id, buf, buf_size);
	}

	if (rc == -ENOTSUPP && ic_dev->debug.set_func_data != NULL)
		return ic_dev->debug.set_func_data(ic_dev, func_id, buf, buf_size);

	return rc;
}
